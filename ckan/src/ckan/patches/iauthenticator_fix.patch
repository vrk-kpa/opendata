diff --git a/ckan/config/middleware/common_middleware.py b/ckan/config/middleware/common_middleware.py
index 92b448c3e..0ff2f7ad8 100644
--- a/ckan/config/middleware/common_middleware.py
+++ b/ckan/config/middleware/common_middleware.py
@@ -1,6 +1,7 @@
 # encoding: utf-8

 """Additional middleware used by the Flask app stack."""
+from __future__ import annotations
 import hashlib
 from typing import Any

@@ -20,7 +21,7 @@ class RootPathMiddleware(object):
     path and ckan addes the root url causing a duplication of the root path.
     This is a middleware to ensure that even redirects use this logic.
     '''
-    def __init__(self, app: CKANApp):
+    def __init__(self, app: Any):
         self.app = app

     def __call__(self, environ: Any, start_response: Any):
@@ -33,7 +34,7 @@ class RootPathMiddleware(object):

 class TrackingMiddleware(object):

-    def __init__(self, app: CKANApp, config: CKANConfig):
+    def __init__(self, app: Any, config: CKANConfig):
         self.app = app
         self.engine = sa.create_engine(config.get('sqlalchemy.url'))

diff --git a/ckan/config/middleware/flask_app.py b/ckan/config/middleware/flask_app.py
index 8d34f5219..abf733a4a 100644
--- a/ckan/config/middleware/flask_app.py
+++ b/ckan/config/middleware/flask_app.py
@@ -43,21 +43,24 @@ from ckan.common import config, g, request, ungettext
 from ckan.config.middleware.common_middleware import (TrackingMiddleware,
                                                       HostHeaderMiddleware,
                                                       RootPathMiddleware)
+import ckan.lib.api_token as api_token
 import ckan.lib.app_globals as app_globals
 import ckan.lib.plugins as lib_plugins
 from ckan.lib.webassets_tools import get_webassets_path
+from ckan.lib.i18n import get_locales_from_config
+
+from ckan.plugins import (
+    PluginImplementations,
+    IBlueprint, IMiddleware, ITranslation, IAuthenticator,
+)

-from ckan.plugins import PluginImplementations
-from ckan.plugins.interfaces import IBlueprint, IMiddleware, ITranslation
 from ckan.views import (identify_user,
                         set_cors_headers_for_response,
                         set_controller_and_action,
                         set_cache_control_headers_for_response,
-                        handle_i18n,
                         set_ckan_current_url,
-                        _get_user_for_apitoken,
                         )
-from ckan.types import CKANApp, Config, Response
+from ckan.types import CKANApp, Config, Response, Request

 log = logging.getLogger(__name__)

@@ -73,7 +76,7 @@ csrf_warn_extensions = (


 class I18nMiddleware(object):
-    def __init__(self, app: CKANApp):
+    def __init__(self, app: Any):
         self.app = app

     def __call__(self, environ: Any, start_response: Any):
@@ -81,6 +84,37 @@ class I18nMiddleware(object):
         handle_i18n(environ)
         return self.app(environ, start_response)

+def handle_i18n(base_environ: dict[str, Any] | None) -> None:
+    '''
+    Strips the locale code from the requested url
+    (eg '/sk/about' -> '/about') and sets environ variables for the
+    language selected:
+        * CKAN_LANG is the language code eg en, fr
+        * CKAN_LANG_IS_DEFAULT is set to True or False
+        * CKAN_CURRENT_URL is set to the current application url
+    '''
+    environ = base_environ or request.environ
+    locale_list = get_locales_from_config()
+    default_locale = config.get('ckan.locale_default')
+
+    # We only update once for a request so we can keep
+    # the language and original url which helps with 404 pages etc
+    if 'CKAN_LANG' not in environ:
+        path_parts = environ['PATH_INFO'].split('/')
+        if len(path_parts) > 1 and path_parts[1] in locale_list:
+            environ['CKAN_LANG'] = path_parts[1]
+            environ['CKAN_LANG_IS_DEFAULT'] = False
+            # rewrite url
+            if len(path_parts) > 2:
+                environ['PATH_INFO'] = '/'.join([''] + path_parts[2:])
+            else:
+                environ['PATH_INFO'] = '/'
+        else:
+            environ['CKAN_LANG'] = default_locale
+            environ['CKAN_LANG_IS_DEFAULT'] = True
+
+        set_ckan_current_url(environ)
+

 class CKANBabel(Babel):
     app: CKANApp
@@ -297,37 +331,8 @@ def make_flask_stack(conf: Union[Config, CKANConfig]) -> CKANApp:
     login_manager.anonymous_user = model.AnonymousUser
     # The name of the view to redirect to when the user needs to log in.
     login_manager.login_view = config.get("ckan.auth.login_view")
-
-    @login_manager.user_loader
-    def load_user(user_id: str) -> Optional["model.User"]:  # type: ignore
-        """
-        This callback function is called whenever we need to reload from
-        the database the logged in user in the session (ie the cookie).
-
-        Site maintainers can choose to completely ignore cookie based
-        authentication for API calls, but that will break existing JS widgets
-        that rely on API calls so it should be used with caution.
-        """
-        endpoint = request.endpoint or ""
-        is_api = endpoint.split(".")[0] == "api"
-        if (
-            not config.get("ckan.auth.enable_cookie_auth_in_api")
-                and is_api):
-            return
-
-        return model.User.get(user_id)
-
-    @login_manager.request_loader
-    def load_user_from_request(request):  # type: ignore
-        """
-        This callback function is called whenever a user could not be
-        authenticated via the session cookie, so we fall back to the API token.
-        """
-        g.login_via_auth_header = True
-
-        user = _get_user_for_apitoken()
-
-        return user
+    login_manager.user_loader(load_user)
+    login_manager.request_loader(load_user_from_request)

     # Update the main CKAN config object with the Flask specific keys
     # that were set here or autogenerated
@@ -335,20 +340,83 @@ def make_flask_stack(conf: Union[Config, CKANConfig]) -> CKANApp:
     for key in flask_config_keys:
         config[key] = flask_app.config[key]

-    # Prevent the host from request to be added to the new header location.
-    app = HostHeaderMiddleware(app)
-
-    app = I18nMiddleware(app)
+    # Prevent the host from request to be added to the new header
+    # location. Here `wsgi_app` can be missing if IMiddleware plugin replaces
+    # app instead of adding before/after request callbacks.
+    app.wsgi_app = HostHeaderMiddleware(getattr(app, "wsgi_app", app))
+    app.wsgi_app = I18nMiddleware(app.wsgi_app)

     if config.get('ckan.tracking_enabled'):
         app = TrackingMiddleware(app, config)

-    # Add a reference to the actual Flask app so it's easier to access
-    # type_ignore_reason: custom attribute
-    app._wsgi_app = flask_app  # type: ignore
+    # Add a reference to the actual Flask app so it's easier to access. It can
+    # be not required as CKAN does not replaces Flask app starting from
+    # v2.12. But some extensions still can do it due to incorrect
+    # implementation of IMiddleware.
+    setattr(app, "_wsgi_app", flask_app)

     return app

+def load_user(user_id: str) -> model.User | model.AnonymousUser | None:
+    """
+    This callback function is called whenever we need to reload from
+    the database the logged in user in the session (ie the cookie).
+    Site maintainers can choose to completely ignore cookie based
+    authentication for API calls, but that will break existing JS widgets
+    that rely on API calls so it should be used with caution.
+    """
+    endpoint = request.endpoint or ""
+    is_api = endpoint.split(".")[0] == "api"
+    if is_api and not config["ckan.auth.enable_cookie_auth_in_api"]:
+        return
+
+    for p in PluginImplementations(IAuthenticator):
+        if user := p.identify_user(user_id):
+            return user
+
+    # give API Token authentication higher precedence than default session
+    # login
+    if user := _get_user_for_apitoken():
+        g.login_via_auth_header = True
+        return user
+
+    return model.User.get(user_id)
+
+
+def load_user_from_request(
+    request: Request
+) -> model.User | model.AnonymousUser | None:
+    """
+    This callback function is called whenever a user could not be
+    authenticated via the session cookie, so we fall back to the API token.
+    """
+    for p in PluginImplementations(IAuthenticator):
+        if user := p.identify_user():
+            return user
+
+    # similar lines are executed when user loaded from session. There they are
+    # used to override session information using header. Here they are used as
+    # fallback, when session does not exist.
+    if user := _get_user_for_apitoken():
+        g.login_via_auth_header = True
+        return user
+
+
+def _get_user_for_apitoken() -> model.User | None:
+    apitoken_header_name = config["apitoken_header_name"]
+    apitoken: str = request.headers.get(apitoken_header_name, "")
+
+    if not apitoken:
+        return None
+    apitoken = str(apitoken)
+    user = api_token.get_user_from_token(apitoken)
+    log.debug(
+        'Received API Token: %s[...]. Identified user: %s',
+        apitoken[:10],
+        user.name if user else None,
+    )
+
+    return user

 def get_locale() -> str:
     u'''
@@ -603,9 +671,7 @@ def _register_core_blueprints(app: CKANApp):
 def _register_error_handler(app: CKANApp):
     u'''Register error handler'''

-    def error_handler(e: Exception) -> Union[
-        tuple[str, Optional[int]], Optional[Response]
-    ]:
+    def error_handler(e: Exception) -> tuple[str, int]:
         debug = config.get('debug')
         if isinstance(e, HTTPException):
             if debug:
@@ -623,7 +689,7 @@ def _register_error_handler(app: CKANApp):
                 u'show_login_redirect_link': show_login_redirect_link
             }
             return base.render(
-                u'error_document_template.html', extra_vars), e.code
+                u'error_document_template.html', extra_vars), e.code or 500

         log.error(e, exc_info=sys.exc_info)  # type: ignore
         extra_vars = {u'code': [500], u'content': u'Internal server error'}
@@ -682,7 +748,7 @@ Headers:            %(headers)s


 def _setup_webassets(app: CKANApp):
-    app.use_x_sendfile = config.get('ckan.webassets.use_x_sendfile')
+    app.use_x_sendfile = config.get('ckan.webassets.use_x_sendfile') # type: ignore

     webassets_folder = get_webassets_path()

diff --git a/ckan/plugins/interfaces.py b/ckan/plugins/interfaces.py
index cc3794569..6ac2bed32 100644
--- a/ckan/plugins/interfaces.py
+++ b/ckan/plugins/interfaces.py
@@ -1633,45 +1633,74 @@ class IFacets(Interface):


 class IAuthenticator(Interface):
-    u'''Allows custom authentication methods to be integrated into CKAN.
-
-        All interface methods except for the ``abort()`` one support
-        returning a Flask response object. This can be used for instance to
-        issue redirects or set cookies in the response. If a response object
-        is returned there will be no further processing of the current request
-        and that response will be returned. This can be used by plugins to:
-
-        * Issue a redirect::
-
-            def identify(self):
-
-                return toolkit.redirect_to('myplugin.custom_endpoint')
-
-        * Set or clear cookies (or headers)::
-
-            from Flask import make_response
-
-            def identify(self)::
-
-                response = make_response(toolkit.render('my_page.html'))
-                response.set_cookie(cookie_name, expires=0)
-
-                return response
+    '''Allows custom authentication methods to be integrated into CKAN.
+
+    Interface methods :py:meth:`.login`, :py:meth:`.logout` and deprecated
+    :py:meth:`.identify` support returning a Flask response object. This can be
+    used for instance to issue redirects or set cookies in the response. If a
+    response object is returned there will be no further processing of the
+    current request and that response will be returned. This can be used by
+    plugins to:
+    * Issue a redirect::
+        def login(self):
+            return toolkit.redirect_to('myplugin.custom_endpoint')
+    * Set or clear cookies (or headers)::
+        from flask import make_response
+        def login(self)::
+            response = make_response(toolkit.render('my_page.html'))
+            response.set_cookie(cookie_name, expires=0)
+            return response
+    Instead of using :py:meth:`.identify` in this role, it's recommended to use
+    :py:class:`~ckan.plugins.interfaces.IMiddleware` interfaces. Its
+    :py:meth:`~ckan.plugins.interfaces.IMiddleware.make_middleware` accpets
+    ``app`` object that can be supplied with before-request callback::
+        p.implements(IMiddleware, inherit=True)
+        def make_middleware(self, app):
+            app.before_request(
+                lambda: toolkit.redirect_to('myplugin.custom_endpoint')
+            )

     '''

-    def identify(self) -> Optional[Response]:
-        u'''Called to identify the user.
-
-        If the user is identified then it should set:
-
-         - g.user: The name of the user
-         - g.userobj: The actual user object
+    def identify_user(
+        self, user_id: str | None = None,
+    ) -> model.User | model.AnonymousUser | None:
+        """Load a user using.
+        When :py:func:`~ckan.plugins.toolkit.ckan.plugins.toolkit.login_user`
+        is called with a user object, user's ID is saved in the session. After
+        that, in the beginning of each request the same user's ID from the
+        session is used to get user details via :py:meth:`.identify_user`.
+        If all implementations of the method return ``None`` when called with
+        non-empty ``user_id``, application assumes that the user stored in the
+        session is not valid and calls the method once again, but without
+        arguments this time. At this point implementations have a chance to
+        identify user using request details or any other appropriate source of
+        user's identity.
+        The implementation returns:
+        * a :py:class:`~ckan.model.User` object if user is identified
+        * a :py:class:`~ckan.model.AnonymousUser` object if user definitely is
+          not authenticated and identification from following plugins must be
+          ignored.
+        * ``None`` if the user cannot be identified by the current
+          implementation, but there is a chance that following plugins can
+          identify it.
+        If any implementation returns :py:class:`~ckan.model.AnonymousUser` for
+        call with ``user_id``, no further processing happens and app treats the
+        request as an anonymous request. If all implementations return
+        ``None``, :py:meth:`.identify_user` will be called once again without
+        arguments.
+        """
+        return None

-        Alternatively, plugins can return a response object in order to prevent
-        the default CKAN authorization flow. See
-        the :py:class:`~ckan.plugins.interfaces.IAuthenticator` documentation
-        for more details.
+    def identify(self) -> Optional[Response]:
+        '''DEPRECATED. Called for side effects before the request.
+        Formerly it was used to identify a user during the request. This
+        responsibility is moved to :py:meth:`.identify_user`. The
+        current method can perform side-effects or produce a response object to
+        stop further processing of the requests. More idiomatic way to achieve
+        both goals is using Flask's ``app.before_request`` callback, that can
+        be registered using
+        :py:meth:`~ckan.plugins.interfaces.IMiddleware.make_middleware` method.

         '''

diff --git a/ckan/types/__init__.py b/ckan/types/__init__.py
index ea51594a5..7bd666d17 100644
--- a/ckan/types/__init__.py
+++ b/ckan/types/__init__.py
@@ -24,6 +24,7 @@ from .model import (
 )

 if TYPE_CHECKING:
+    from ckan.config.middleware.flask_app import CKANFlask
     from ckanext.activity.model import Activity


@@ -43,7 +44,7 @@ __all__ = [
     "PFeed", "PFeedFactory", "PResourceUploader", "PUploader",
 ]
 Config: TypeAlias = Dict[str, Union[str, Mapping[str, str]]]
-CKANApp = Any
+CKANApp: TypeAlias = "CKANFlask"

 # dictionary passed to actions
 DataDict: TypeAlias = "dict[str, Any]"
diff --git a/ckan/views/__init__.py b/ckan/views/__init__.py
index 514d7d683..b1618a6bc 100644
--- a/ckan/views/__init__.py
+++ b/ckan/views/__init__.py
@@ -8,10 +8,7 @@ import six
 from urllib.parse import quote
 from flask.wrappers import Response

-import ckan.model as model
-import ckan.lib.api_token as api_token
 from ckan.common import g, request, config, current_user, logout_user
-from ckan.lib.i18n import get_locales_from_config
 import ckan.plugins as p

 import logging
@@ -72,11 +69,11 @@ def set_cache_control_headers_for_response(response: Response) -> Response:
     return response


-def identify_user() -> Optional[Response]:
-    u'''This function exists only to maintain backward compatibility
+def identify_user() -> Response | None:
+    '''This function exists only to maintain backward compatibility
     to extensions that still need g.user/g.userobj.

-    Note: flask_login now identifies users for us behind the scene.
+    Note: flask_login now identifies users upon first access to `current_user`.
     '''
     # see if it was proxied first
     g.remote_addr = request.environ.get(u'HTTP_X_FORWARDED_FOR', u'')
@@ -84,108 +81,29 @@ def identify_user() -> Optional[Response]:
         g.remote_addr = request.environ.get(u'REMOTE_ADDR',
                                             u'Unknown IP Address')

-    # Authentication plugins get a chance to run here break as soon as a user
-    # is identified or a response is returned
-    authenticators = p.PluginImplementations(p.IAuthenticator)
-    if authenticators:
-        for item in authenticators:
-            response = item.identify()
-            if response:
-                return response
-            try:
-                if current_user.is_authenticated or g.user:
-                    break
-            except AttributeError:
-                continue
-    # sets the g.user/g.userobj for extensions
-    g.user = current_user.name
-    g.userobj = '' if current_user.is_anonymous else current_user
-
     # logout, if a user that was still logged in is deleted.
-    if current_user.is_authenticated:
-        if not current_user.is_active:
-            logout_user()
-
-    # If we have a user but not the userobj let's get the userobj. This means
-    # that IAuthenticator extensions do not need to access the user model
-    # directly.
-    if g.user:
-        if not getattr(g, u'userobj', None):
-            g.userobj = model.User.by_name(g.user)
-
-    # general settings
-    if g.user:
-        if g.userobj:
-            userobj = model.User.by_name(g.user)
-            userobj.set_user_last_active()  # type: ignore
-        g.author = g.user
-    else:
-        g.author = g.remote_addr
-    g.author = str(g.author)
-
+    if current_user.is_authenticated and not current_user.is_active:
+        logout_user()

-def _get_user_for_apitoken() -> Optional[model.User]:  # type: ignore
-    apitoken_header_name = config.get("apikey_header_name")
+    # sets the g.user/g.userobj for extensions
+    g.user = current_user.name
+    g.userobj = current_user if current_user.is_authenticated else None

-    apitoken: str = request.headers.get(apitoken_header_name, u'')
-    if not apitoken:
-        apitoken = request.environ.get(apitoken_header_name, u'')
-    if not apitoken:
-        # For misunderstanding old documentation (now fixed).
-        apitoken = request.environ.get(u'HTTP_AUTHORIZATION', u'')
-    if not apitoken:
-        apitoken = request.environ.get(u'Authorization', u'')
-        # Forget HTTP Auth credentials (they have spaces).
-        if u' ' in apitoken:
-            apitoken = u''
-    if not apitoken:
-        return None
-    apitoken = six.ensure_text(apitoken, errors=u"ignore")
-    log.debug(u'Received API Token: %s' % apitoken)
+    # Authentication plugins can break here if a response is returned.
+    for item in p.PluginImplementations(p.IAuthenticator):
+        if response := item.identify():
+            return response

-    user = api_token.get_user_from_token(apitoken)
+    if current_user.is_authenticated:
+        current_user.set_user_last_active()  # type: ignore

-    return user
+    g.author = g.user or g.remote_addr or ""


 def set_controller_and_action() -> None:
     g.blueprint, g.view = p.toolkit.get_endpoint()


-def handle_i18n(environ: Optional[dict[str, Any]] = None) -> None:
-    u'''
-    Strips the locale code from the requested url
-    (eg '/sk/about' -> '/about') and sets environ variables for the
-    language selected:
-
-        * CKAN_LANG is the language code eg en, fr
-        * CKAN_LANG_IS_DEFAULT is set to True or False
-        * CKAN_CURRENT_URL is set to the current application url
-    '''
-    environ = environ or request.environ
-    assert environ
-    locale_list = get_locales_from_config()
-    default_locale = config.get(u'ckan.locale_default')
-
-    # We only update once for a request so we can keep
-    # the language and original url which helps with 404 pages etc
-    if u'CKAN_LANG' not in environ:
-        path_parts = environ[u'PATH_INFO'].split(u'/')
-        if len(path_parts) > 1 and path_parts[1] in locale_list:
-            environ[u'CKAN_LANG'] = path_parts[1]
-            environ[u'CKAN_LANG_IS_DEFAULT'] = False
-            # rewrite url
-            if len(path_parts) > 2:
-                environ[u'PATH_INFO'] = u'/'.join([u''] + path_parts[2:])
-            else:
-                environ[u'PATH_INFO'] = u'/'
-        else:
-            environ[u'CKAN_LANG'] = default_locale
-            environ[u'CKAN_LANG_IS_DEFAULT'] = True
-
-        set_ckan_current_url(environ)
-
-
 def set_ckan_current_url(environ: Any) -> None:
     # Current application url
     path_info = environ[u'PATH_INFO']
